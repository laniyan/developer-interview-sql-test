DROP TABLE IF EXISTS example_1.product_prices;
DROP TABLE IF EXISTS example_1.products;
DROP SCHEMA IF EXISTS example_1;
CREATE SCHEMA example_1;

CREATE TABLE example_1.products (
	id int4 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	name text NOT NULL,
	CONSTRAINT pk_products PRIMARY KEY (id)
);
 
CREATE TABLE example_1.product_prices (
	id int4 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	product_id int4 NOT NULL,
	product_price numeric NOT NULL,
	published_date date NOT NULL,
	CONSTRAINT pk_product_prices PRIMARY KEY (id)
);
ALTER TABLE example_1.product_prices ADD CONSTRAINT fk_product_prices_product FOREIGN KEY (product_id) REFERENCES example_1.products(id) ON DELETE CASCADE;


INSERT INTO example_1.products (name)
SELECT concat('Product-', id) 
FROM generate_series(1, 10000, 1) AS id;


INSERT INTO example_1.product_prices (product_id, product_price, published_date)
SELECT p.id, ROUND((random() * 100 + 1)::numeric, 2), ('2022-12-31'::date - random() * INTERVAL '365 days')::date
FROM example_1.products p
CROSS JOIN 
(
	SELECT generate_series(1, 100, 1) d
) AS dates;


-- Answer
-- Step 3 : Create indexes to improve query performance
CREATE INDEX idx_product_prices_product_id ON example_1.product_prices (product_id);
CREATE INDEX idx_product_prices_published_date ON example_1.product_prices (published_date);

-- Step 4 : Construct and execute the query using Common Table Expression (CTE)
WITH latest_product_prices AS (
    SELECT DISTINCT ON (product_id) 
        product_id, 
        product_price, 
        published_date
    FROM example_1.product_prices
    WHERE published_date <= '2022-06-10'
    AND product_id IN (100, 200, 300, 400)
    ORDER BY product_id, published_date DESC
)
SELECT 
    p.name AS product_name, 
    lp.product_price, 
    lp.published_date
FROM latest_product_prices lp
JOIN example_1.products p ON lp.product_id = p.id;
