DROP TABLE IF EXISTS example_3.product_prices;
DROP TABLE IF EXISTS example_3.products;
DROP SCHEMA IF EXISTS example_3;
CREATE SCHEMA example_3;

CREATE TABLE example_3.products (
	id int4 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	name text NOT NULL,
	unit_of_measure text NOT NULL,
	CONSTRAINT pk_products PRIMARY KEY (id)
);
 
CREATE TABLE example_3.product_prices (
	id int4 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	product_id int4 NOT NULL,
	product_price numeric NOT NULL,
	published_date date NOT NULL,
	unit_of_measure text NOT NULL,
	CONSTRAINT pk_product_prices PRIMARY KEY (id)
);
ALTER TABLE example_3.product_prices ADD CONSTRAINT fk_product_prices_product FOREIGN KEY (product_id) REFERENCES example_3.products(id) ON DELETE CASCADE;


INSERT INTO example_3.products (name, unit_of_measure)
SELECT concat('Product-', id),
       CASE WHEN ROUND((random())::numeric) = 0 THEN 'GA' ELSE 'KG' END
FROM generate_series(1, 1000, 1) AS id;


INSERT INTO example_3.product_prices (product_id, product_price, published_date, unit_of_measure)
SELECT p.id,
       ROUND((random() * 100 + 1)::numeric, 2), 
       ('2022-12-31'::date - random() * INTERVAL '365 days')::date,
       CASE WHEN ROUND((random())::numeric) = 0 THEN 'GA' ELSE 'KG' END
FROM example_3.products p
CROSS JOIN 
(
	SELECT generate_series(1, 100, 1) d
) AS dates;


-- Answer

-- Step 3: Create indexes to optimize the query
CREATE INDEX idx_product_unit_of_measure ON example_3.products (unit_of_measure);
CREATE INDEX idx_product_prices_product_id_unit_of_measure ON example_3.product_prices (product_id, unit_of_measure);

-- Step 4: Create the view
CREATE VIEW example_3.valid_prices AS
SELECT 
    pp.id AS price_id, 
    p.id AS product_id, 
    p.name AS product_name, 
    pp.product_price, 
    pp.published_date, 
    pp.unit_of_measure
FROM 
    example_3.product_prices pp
JOIN 
    example_3.products p ON pp.product_id = p.id
WHERE 
    pp.unit_of_measure = p.unit_of_measure;

-- Step 5: Query the view to verify
SELECT * FROM example_3.valid_prices;